"""
Author: XIN LI

TODO:
* Derive a "abstractive definition", which can be automatically generated by model.
* such "abstractive definition" (using [Probability Rules] to represent) should be:

abstractive:
- human: cover all humen, but can not be used to represent a specific human (black, white, yellow)
- color: cover all colors, but can not be used to represent a specific color (green, red, yellow)
- seven, cover all sevens, but can not be used to represent a specific hand-writing "7"

definition:
- human: leg, arm, heads; but all these components are allow to be different and yet similar in some ways




Using playing saxophone as an example.

A particular "KEY" is hard-defined to be a KEY on the saxophone. But every time you play the KEY, it will be 
different (similar, but never the same as last time, due to the air blow).

So, how can i setup a similar hard-defined KEY in my model (instead of on the sax)?







inheritable difference: 


Normalize the scale to the same:
- X => 0 ~ 1
- Y => 0 ~ 1
- X => min ~ max





what's the meaning of "alike"?
- in statistics, we use "distance" to evaluate the "likeness"
- in abstraction, we can try to use "substitutability" to evaluate the "likeness"






when you close your eyes, imagin a pattern, you see it, but actually you didn't,
because it's actually all black when you close your eyes. it is the brain that
read and give you a memory of such pattern to "make you think" you see it.

the amazing part is that, since there is not actual pattern to relfect the light into
eyes to see such pattern, and human can not remember the "pixel values" to remember the pattern,
how we store such pattern in our memory and read it out when we close our eyes?
"""
# ---------------------------------- customized libs
from utils import *
from feel import Feel
from nobo import NOBO
from btb import BTB
# ---------------------------------- open-source libs
from mnist import MNIST
from matplotlib import pyplot as plt
import numpy as np
import random
import math
from PIL import Image
from mpl_toolkits.mplot3d import Axes3D

mndata = MNIST('dataset')
images_train, labels_train = mndata.load_training()
images_test, labels_test = mndata.load_testing()


# ################################################## init
#isTraining = True
isTraining = False

# -------------------------------------------------- train
#isRandom = True
isRandom = False
training_size = 25
size_train = training_size * 10
# -------------------------------------------------- test
testing_size = 50
size_test = testing_size * 10

# TODO: try different weights
# ---------------------- weight of abstraction lvl
w1 = 1.5
w2 = 1.3
w3 = 1.1
# ---------------------- 

correctness = 0
local_correctness = [0] * 10

# -------------------------------------------------- save
path_to_file1 = "_saved/save_spectial_10_lvl1"
path_to_file2 = "_saved/save_spectial_10_lvl2"
path_to_file3 = "_saved/save_spectial_10_lvl3"
"""
path_to_file1 = "_saved/save_" + str(training_size) + "_lvl1"
path_to_file2 = "_saved/save_" + str(training_size) + "_lvl2"
path_to_file3 = "_saved/save_" + str(training_size) + "_lvl3"
"""
# ################################################## init



def illus_1(m, target):
	p = []

	for i in range(10):
		temp = []
		for a in range(16):
			for b in range(16):
				if m[i, a, b] != 0:
					temp.append([a, b])
		p.append(temp)

	for i in p[target]:
		print(i)

	print(len(p[target]))
	print(m.shape)


def illus_2(m, target):
	p = []

	for i in range(10):
		temp = []
		for a in range(16):
			for b in range(16):
				for c in range(16):
					if m[i, a, b, c] != 0:
						temp.append([a, b, c])
		p.append(temp)

	for i in p[target]:
		print(i)

	print(len(p[target]))


def illus_3(m, target):
	p = []

	for i in range(10):
		temp = []
		for a in range(16):
			for b in range(16):
				for c in range(16):
					for d in range(16):
						if m[i, a, b, c, d] != 0:
							temp.append([a, b, c, d])
		p.append(temp)

	for i in p[target]:
		print(i)

	print(len(p[target]))
















if isTraining:
	enc_tracker = [0] * 10

	model1 = np.zeros((10, 16, 16), dtype = np.float)
	model2 = np.zeros((10, 16, 16, 16), dtype = np.float)
	model3 = np.zeros((10, 16, 16, 16, 16), dtype = np.float)
	
	imgs, labs = get_data(size_train, isTraining, isRandom)

	ep = len(imgs)

	for i in range(ep):
		print("Training ... ... ... ... " + str(ep) + " - " + str(i))

		img = imgs[i]
		lab = labs[i]

		btb = BTB(2, img)
		btb.perception()

		model1[lab, :, :] = model1[lab, :, :] + btb.lvl1
		model2[lab, :, :, :] = model2[lab, :, :, :] + btb.lvl2
		model3[lab, :, :, :, :] = model3[lab, :, :, :] + btb.lvl3

		enc_tracker[lab] = enc_tracker[lab] + 1

	for i in range(10):
		norm = float(enc_tracker[i])
		model1[i, :, :] = model1[i, :, :] / norm
		model2[i, :, :, :] = model2[i, :, :, :] / norm
		model3[i, :, :, :, :] = model3[i, :, :, :] / norm

	print("#####################")
	np.save(path_to_file1, model1)
	np.save(path_to_file2, model2)
	np.save(path_to_file3, model3)
	print("... models are saved!")
	print("#####################")

else:
	m1 = np.load(path_to_file1 + ".npy")
	m2 = np.load(path_to_file2 + ".npy")
	m3 = np.load(path_to_file3 + ".npy")

	rm_same(m1, m2, m3)

	





	"""
	mndata = MNIST('dataset')
	images_train, labels_train = mndata.load_training()
	images_test, labels_test = mndata.load_testing()

	# --------------------------------- load hand-writing data
	#idx = 6 # 1
	#idx = 16 # 2
	#idx = 12 # 3
	#idx = 91 # 7
	idx = 29 # 7

	img = images_train[idx]
	img = np.array(img, dtype='float').reshape((28, 28))

	img = prep_data(img)

	btb = BTB(2, img)
	btb.perception()

	r1 = btb.lvl1
	r2 = btb.lvl2
	r3 = btb.lvl3
	"""

























	



	"""
	###################################### 1
	[9, 0]
	[9, 1]
	[9, 2]
	[9, 4]
	[9, 8]
	###################################### 2
	[9, 1, 1]
	[9, 1, 2]
	[9, 1, 4]
	[9, 1, 8]
	[9, 2, 1]
	[9, 2, 2]
	[9, 2, 4]
	[9, 2, 8]
	[9, 4, 1]
	[9, 4, 2]
	[9, 4, 4]
	[9, 4, 8]
	[9, 8, 1]
	[9, 8, 2]
	[9, 8, 4]
	[9, 8, 8]
	###################################### 2
		[3, 1, 1, 1]
	[3, 1, 1, 2]
	[3, 1, 1, 4]
	[3, 1, 1, 8]
	[3, 1, 1, 11]
	[3, 1, 1, 12]
	[3, 1, 1, 14]
	[3, 1, 2, 1]
	[3, 1, 2, 2]
	[3, 1, 2, 4]
	[3, 1, 2, 5]
	[3, 1, 2, 8]
	[3, 1, 2, 10]
	[3, 1, 2, 12]
	[3, 1, 2, 13]
	[3, 1, 3, 1]
	[3, 1, 3, 2]
	[3, 1, 3, 4]
	[3, 1, 3, 8]
	[3, 1, 4, 1]
	[3, 1, 4, 2]
	[3, 1, 4, 4]
	[3, 1, 4, 6]
	[3, 1, 4, 8]
	[3, 1, 4, 10]
	[3, 1, 4, 11]
	[3, 1, 4, 12]
	[3, 1, 4, 13]
	[3, 1, 4, 14]
	[3, 1, 5, 8]
	[3, 1, 6, 4]
	[3, 1, 6, 8]
	[3, 1, 8, 1]
	[3, 1, 8, 2]
	[3, 1, 8, 4]
	[3, 1, 8, 5]
	[3, 1, 8, 6]
	[3, 1, 8, 8]
	[3, 1, 8, 10]
	[3, 1, 8, 12]
	[3, 1, 8, 13]
	[3, 1, 9, 4]
	[3, 1, 9, 8]
	[3, 1, 10, 8]
	[3, 1, 12, 1]
	[3, 1, 12, 2]
	[3, 1, 12, 4]
	[3, 1, 12, 8]
	[3, 2, 1, 1]
	[3, 2, 1, 2]
	[3, 2, 1, 4]
	[3, 2, 1, 5]
	[3, 2, 1, 6]
	[3, 2, 1, 8]
	[3, 2, 1, 10]
	[3, 2, 1, 11]
	[3, 2, 1, 12]
	[3, 2, 2, 1]
	[3, 2, 2, 4]
	[3, 2, 2, 5]
	[3, 2, 2, 6]
	[3, 2, 2, 7]
	[3, 2, 2, 8]
	[3, 2, 2, 12]
	[3, 2, 3, 4]
	[3, 2, 3, 8]
	[3, 2, 4, 1]
	[3, 2, 4, 2]
	[3, 2, 4, 4]
	[3, 2, 4, 5]
	[3, 2, 4, 6]
	[3, 2, 4, 8]
	[3, 2, 4, 9]
	[3, 2, 4, 10]
	[3, 2, 4, 11]
	[3, 2, 4, 12]
	[3, 2, 8, 1]
	[3, 2, 8, 4]
	[3, 2, 8, 5]
	[3, 2, 8, 7]
	[3, 2, 8, 8]
	[3, 2, 8, 12]
	[3, 2, 8, 14]
	[3, 2, 9, 4]
	[3, 2, 9, 8]
	[3, 2, 12, 4]
	[3, 2, 12, 8]
	[3, 3, 1, 2]
	[3, 3, 1, 4]
	[3, 3, 1, 8]
	[3, 3, 1, 9]
	[3, 3, 1, 11]
	[3, 3, 1, 12]
	[3, 3, 2, 4]
	[3, 3, 2, 5]
	[3, 3, 2, 8]
	[3, 3, 2, 11]
	[3, 3, 2, 12]
	[3, 3, 3, 4]
	[3, 3, 3, 8]
	[3, 3, 3, 9]
	[3, 3, 3, 12]
	[3, 3, 4, 2]
	[3, 3, 4, 4]
	[3, 3, 4, 8]
	[3, 3, 4, 9]
	[3, 3, 4, 11]
	[3, 3, 4, 12]
	[3, 3, 6, 4]
	[3, 3, 6, 8]
	[3, 3, 8, 4]
	[3, 3, 8, 5]
	[3, 3, 8, 8]
	[3, 3, 8, 11]
	[3, 3, 8, 12]
	[3, 3, 9, 4]
	[3, 3, 9, 8]
	[3, 3, 12, 4]
	[3, 3, 12, 8]
	[3, 3, 12, 9]
	[3, 3, 12, 12]
	[3, 4, 1, 1]
	[3, 4, 1, 2]
	[3, 4, 1, 4]
	[3, 4, 1, 8]
	[3, 4, 1, 9]
	[3, 4, 1, 11]
	[3, 4, 1, 12]
	[3, 4, 2, 1]
	[3, 4, 2, 2]
	[3, 4, 2, 4]
	[3, 4, 2, 5]
	[3, 4, 2, 8]
	[3, 4, 2, 10]
	[3, 4, 2, 12]
	[3, 4, 2, 13]
	[3, 4, 3, 4]
	[3, 4, 3, 8]
	[3, 4, 4, 1]
	[3, 4, 4, 2]
	[3, 4, 4, 3]
	[3, 4, 4, 4]
	[3, 4, 4, 5]
	[3, 4, 4, 6]
	[3, 4, 4, 8]
	[3, 4, 4, 9]
	[3, 4, 4, 10]
	[3, 4, 4, 12]
	[3, 4, 5, 2]
	[3, 4, 5, 8]
	[3, 4, 8, 1]
	[3, 4, 8, 2]
	[3, 4, 8, 3]
	[3, 4, 8, 4]
	[3, 4, 8, 5]
	[3, 4, 8, 8]
	[3, 4, 8, 9]
	[3, 4, 8, 10]
	[3, 4, 8, 12]
	[3, 4, 9, 4]
	[3, 4, 9, 8]
	[3, 4, 10, 8]
	[3, 4, 11, 1]
	[3, 4, 11, 2]
	[3, 4, 11, 4]
	[3, 4, 11, 8]
	[3, 4, 12, 1]
	[3, 4, 12, 2]
	[3, 4, 12, 4]
	[3, 4, 12, 8]
	[3, 6, 1, 4]
	[3, 6, 1, 8]
	[3, 6, 1, 12]
	[3, 6, 2, 4]
	[3, 6, 2, 8]
	[3, 6, 2, 12]
	[3, 6, 3, 4]
	[3, 6, 3, 8]
	[3, 6, 4, 4]
	[3, 6, 4, 6]
	[3, 6, 4, 8]
	[3, 6, 4, 12]
	[3, 6, 8, 4]
	[3, 6, 8, 6]
	[3, 6, 8, 8]
	[3, 6, 8, 12]
	[3, 6, 12, 4]
	[3, 6, 12, 8]
	[3, 8, 1, 1]
	[3, 8, 1, 2]
	[3, 8, 1, 4]
	[3, 8, 1, 5]
	[3, 8, 1, 6]
	[3, 8, 1, 8]
	[3, 8, 1, 9]
	[3, 8, 1, 11]
	[3, 8, 1, 12]
	[3, 8, 2, 1]
	[3, 8, 2, 4]
	[3, 8, 2, 5]
	[3, 8, 2, 7]
	[3, 8, 2, 8]
	[3, 8, 2, 12]
	[3, 8, 2, 14]
	[3, 8, 3, 4]
	[3, 8, 3, 8]
	[3, 8, 4, 1]
	[3, 8, 4, 2]
	[3, 8, 4, 3]
	[3, 8, 4, 4]
	[3, 8, 4, 5]
	[3, 8, 4, 6]
	[3, 8, 4, 8]
	[3, 8, 4, 9]
	[3, 8, 4, 10]
	[3, 8, 4, 12]
	[3, 8, 6, 4]
	[3, 8, 6, 5]
	[3, 8, 6, 8]
	[3, 8, 6, 10]
	[3, 8, 8, 1]
	[3, 8, 8, 3]
	[3, 8, 8, 4]
	[3, 8, 8, 5]
	[3, 8, 8, 6]
	[3, 8, 8, 7]
	[3, 8, 8, 8]
	[3, 8, 8, 12]
	[3, 8, 8, 14]
	[3, 8, 9, 1]
	[3, 8, 9, 2]
	[3, 8, 9, 4]
	[3, 8, 9, 8]
	[3, 8, 12, 1]
	[3, 8, 12, 2]
	[3, 8, 12, 4]
	[3, 8, 12, 8]
	[3, 9, 1, 4]
	[3, 9, 1, 8]
	[3, 9, 1, 12]
	[3, 9, 2, 4]
	[3, 9, 2, 8]
	[3, 9, 2, 12]
	[3, 9, 4, 4]
	[3, 9, 4, 8]
	[3, 9, 4, 12]
	[3, 9, 8, 4]
	[3, 9, 8, 8]
	[3, 9, 8, 12]
	[3, 12, 1, 2]
	[3, 12, 1, 4]
	[3, 12, 1, 8]
	[3, 12, 1, 11]
	[3, 12, 1, 12]
	[3, 12, 2, 4]
	[3, 12, 2, 5]
	[3, 12, 2, 8]
	[3, 12, 2, 11]
	[3, 12, 2, 12]
	[3, 12, 3, 4]
	[3, 12, 3, 8]
	[3, 12, 3, 9]
	[3, 12, 3, 12]
	[3, 12, 4, 1]
	[3, 12, 4, 2]
	[3, 12, 4, 3]
	[3, 12, 4, 4]
	[3, 12, 4, 6]
	[3, 12, 4, 8]
	[3, 12, 4, 9]
	[3, 12, 4, 12]
	[3, 12, 6, 4]
	[3, 12, 6, 8]
	[3, 12, 8, 1]
	[3, 12, 8, 2]
	[3, 12, 8, 4]
	[3, 12, 8, 5]
	[3, 12, 8, 6]
	[3, 12, 8, 8]
	[3, 12, 8, 9]
	[3, 12, 8, 10]
	[3, 12, 9, 1]
	[3, 12, 9, 2]
	[3, 12, 9, 4]
	[3, 12, 9, 8]
	[3, 12, 12, 1]
	[3, 12, 12, 2]
	[3, 12, 12, 4]
	[3, 12, 12, 8]
	[3, 12, 12, 9]
	[3, 12, 12, 12]
	"""





















	"""
	fig, axs = plt.subplots(2, 5)
	axs[0, 0].imshow(m1[0])
	axs[0, 1].imshow(m1[1])
	axs[0, 2].imshow(m1[2])
	axs[0, 3].imshow(m1[3])
	axs[0, 4].imshow(m1[4])
	axs[1, 0].imshow(m1[5])
	axs[1, 1].imshow(m1[6])
	axs[1, 2].imshow(m1[7])
	axs[1, 3].imshow(m1[8])
	axs[1, 4].imshow(m1[9])
	plt.show()
	"""







	"""
	enc_tracker = [0] * 10
	imgs, labs = get_data(size_test, isTraining, isRandom)
	ep = len(imgs)

	for i in range(ep):
		print("Testing ... ... ... ... " + str(ep) + " - " + str(i))

		res = []
		res1 = []
		res2 = []
		res3 = []

		img = imgs[i]
		lab = labs[i]
		enc_tracker[lab] = enc_tracker[lab] + 1

		btb = BTB(2, img)
		btb.perception()

		r1 = btb.lvl1.flatten()
		r2 = btb.lvl2.flatten()
		r3 = btb.lvl3.flatten()

		for j in range(10):
			e1 = m1[j].flatten()
			ed1 = np.linalg.norm(e1 - r1)
			res1.append(ed1)

			e2 = m2[j].flatten()
			ed2 = np.linalg.norm(e2 - r2)
			res2.append(ed2)

			e3 = m3[j].flatten()
			ed3 = np.linalg.norm(e3 - r3)
			res3.append(ed3)

		reorder1 = sorted(range(len(res1)), key=lambda k: res1[k])
		reorder2 = sorted(range(len(res2)), key=lambda k: res2[k])
		reorder3 = sorted(range(len(res3)), key=lambda k: res3[k])

		for c in range(10):
			rank_l1 = float(reorder1.index(c)) * w1
			rank_l2 = float(reorder2.index(c)) * w2
			rank_l3 = float(reorder3.index(c)) * w3
			res.append(rank_l1 + rank_l2 + rank_l3)




		# --------------------------------------------- assess (2): in
		res_min = min(res)

		pred = [i for i, x in enumerate(res) if x == res_min]
		print(str(lab) + " - " + str(pred))
		print(sorted(range(len(res)), key=lambda k: res[k]))

		if lab in pred:
			correctness = correctness + 1
			local_correctness[lab] = local_correctness[lab] + 1

	# ---------------------------------------- prep summary
	for i in range(len(local_correctness)):
		local_correctness[i] = float(local_correctness[i]) / float(enc_tracker[i])

	sum_correctness = float(correctness) / float(ep)
	
	print(" ################ Summary ################")
	print(local_correctness)
	print(sum_correctness)
	print("##########################################")
	"""

"""
# --------------------------------------------------------
l1 & l2 & l3 + 25:

[0.72, 0.9, 0.32, 0.8, 0.82, 0.58, 0.64, 0.68, 0.46, 0.54]
0.646
# --------------------------------------------------------
"""













